---
title: 'iSC.MEB: DLPFC Data Analysis'
author: "Xiao Zhang"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{iSC.MEB: DLPFC Data Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  tidy = TRUE,
  fig.width = 11,
  tidy.opts = list(width.cutoff = 95),
  message = FALSE,
  warning = FALSE,
  time_it = TRUE
)
all_times <- list()  # store the time for each chunk
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      now <<- Sys.time()
    } else {
      res <- difftime(Sys.time(), now, units = "secs")
      all_times[[options$label]] <<- res
    }
  }
}))
```

# Intrduction
This vignette introduces the `iSC.MEB` workflow for the analysis of the DLPFC dataset [Maynard K. et al, 2021](https://www.nature.com/articles/s41593-020-00787-0), which contains the spatial topography of gene expression from 12 human postmortem DLPFC tissue sections generated by using the 10x Genomics Visium platform. The workflow consists of three steps

* Independent preprocessing and model setting
* Integrated clustering using `iSC.MEB` model
* Downstream analysis (i.e. visualization of clusters and embeddings)

We demonstrate the use of `iSC.MEB` to a subset of the DLPFC data after filter that are [here](https://github.com/XiaoZhangryy/iSC.MEB/tree/main/vignettes_data), which can be downloaded to the current working path by the following command:
```{r eval=FALSE}
githubURL <- "https://github.com/XiaoZhangryy/iSC.MEB/blob/main/vignettes_data/DLPFC.rda?raw=true"
download.file(githubURL,"DLPFC.rda",mode='wb')
```

The package can be loaded with the command:
```{r  eval = TRUE}
library(iSC.MEB)
library(Seurat)
```

Then load datasets to R 
```{r  eval = TRUE}
load("DLPFC.rda")
```

# Fit an `iSC.MEB` model
First, we view the the spatial transcriptomics data with Visium platform.
```{r  eval = TRUE}
seuList ## a list including two Seurat object
```

## Prepare the `iSC.MEB` Object.
Then, we can create a iSCMEBObj object to prepare for `iSC.MEB` models. And next, we performe create adjacency matrix, dimensionality reduction and set model setting steps in turn. 
```{r  eval = TRUE}
iSCMEBObj <- CreateiSCMEBObject(seuList = seuList, verbose = FALSE, premin.spots=0, postmin.spots=0)
## check the number of genes/features after filtering step
iSCMEBObj@seulist
## Add adjacency matrix list for a iSCMEBObj object to prepare for iSC.MEB model fitting.
iSCMEBObj <-  CreateNeighbors(iSCMEBObj, platform = "Visium")
## run PCA to get low dimensional embeddings
iSCMEBObj <-  runPCA(iSCMEBObj, npcs = 15, pca.method = "APCA")
## Add a model setting in advance for an iSCMEBObj object. verbose = TRUE helps outputing the
## information in the algorithm.
iSCMEBObj <- SetModelParameters(iSCMEBObj, verbose = TRUE)
```


## Fit iSC.MEB 
For function `iSCMEB`, users can specify the number of clusters `K` or set `K` to be an integer vector by using modified MBIC(BIC) to determine `K`. Here, we use user-specified number of clusters. 
```{r  eval = TRUE}
### Given K
iSCMEBObj <- iSCMEB(iSCMEBObj, K= 7)
```

The function `iSCMEB` will automatically choose the optimal path by the `criteria` specified in setting model parameters step. User can slao using function `SelectModel` to select model.
```{r  eval = TRUE}
iSCMEBObj <- SelectModel(iSCMEBObj)
```

## Evaluate performance
The function `idents` can extract the labels provided by `iSC.MEB` method. Therefore, we can evaluate the clustering performance by some metrics, such as `ARI`. 
```{r  eval = TRUE}
LabelList <- lapply(iSCMEBObj@seulist, function(seu) seu@meta.data$layer_guess_reordered)
ARI <- function(x,y) mclust::adjustedRandIndex(x,y)
ari_sections <- sapply(1:2, function(i) ARI(idents(iSCMEBObj)[[i]], LabelList[[i]]))
ari_all <- ARI(unlist(idents(iSCMEBObj)), unlist(LabelList))
print(ari_sections)
print(ari_all)
```

# Visualization
## Spatial scatter plot
In addition to metrics, we can use some visualization functions to measure the clustering results, such as the spatial scatter plot. 
```{r  eval = TRUE}
cols = c("#fb8072", "#bebada", "#80b1d3", "#ffffb3", "#8dd3c7", "#b3de69", "#fdb462")
p1 <- SpaHeatMap(iSCMEBObj, item="cluster", plot_type="Scatter", nrow.legend=1, 
    layout.dim=c(1,2), no_axis=TRUE, cols=cols)
p1
```

## t-SNE plot.
Next, user can visualize the inferred embeddings for biological effects between cell/domain types using two components from either tSNE or UMAP. Here, wo demonstrate the clustering and batch remove performance by t-SNE plot.
```{r  eval = TRUE}
iSCMEBObj <- CalculateTSNE(iSCMEBObj, reduction="iSCMEB", n_comp=2)
library(patchwork)

p2 <- LowEmbedPlot(iSCMEBObj, item="cluster", reduction="TSNE2", point_size=0.3)
p3 <- LowEmbedPlot(iSCMEBObj, item="batch", reduction="TSNE2", point_size=0.3)
p2 + p3
```

# Session information
```{r  eval = TRUE}
sessionInfo()
```